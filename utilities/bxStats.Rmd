---
title: "BX Molecule Report"
author:
    - "Created using HARPY"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    highlight: tango
    number_sections: no
    theme: default
    df_print: kable
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: no
      smooth_scroll: yes
---
```{r echo = F, results = F, message = F}
library(dplyr)
library(ggplot2)
library(magrittr)
library(DT)

#args <- commandArgs(trailingOnly = T)
args <- "~/subset.bx.stats"
infile <- args[1]
bamfile <- gsub(".bx.stats", ".bam", infile)
samplename <- gsub(".bx.stats", "", basename(infile))
tb <- read.table(infile, header = T) %>% select(-start, -end)
tb$valid <- tb$bx
tb[!(tb$valid %in% c("noBX", "invalidBX")), "valid"] <- "validBX"
tb$valid <- gsub("BX", " BX", tb$valid)
tb$fill <- case_when(
    tb$valid == "no BX" ~ "#cf79c8",
    tb$valid == "invalid BX" ~ "#f19a29",
    tb$valid == "valid BX" ~ "#7cb4ec"
)
# pop out and merge noBX and invalid across contigs
invalid <- filter(tb, valid %in% c("no BX", "invalid BX")) %>%
    group_by(valid) %>%
    summarise(
        contig = first(contig),
        reads = sum(reads),
        fill = first(fill),
        length_inferred = 0,
        bx = first(bx),
        aligned_bp = sum(aligned_bp)
        )
# recombine with main dataframe
tb <- rbind(filter(tb, !(valid %in% c("no BX", "invalid BX"))), invalid)
```
### Sample: `r samplename`
The data presented below was gathered from the alignments within ``r basename(bamfile)``. BX barcode validity is classified
into one of three categories:

- `valid BX`: a complete BX barcode was present in the read (i.e. no `00` for any segments)
- `no BX`: no barcode was present in the read
- `invalid BX`: A barcode was present in the read, but it contained `00` for any of the haplotag segments

## Reads per molecule
The chart below shows the distribution of the number of reads per BX molecule. That is, how many alignments
are associated with a particular BX barcode. This also includes the number of reads associated with invalid
or absent BX barcodes.
```{r echo = F}
ggplot(tb, aes(x = reads, fill = fill)) +
    stat_bin(binwidth = 0.5, geom="text", position = "dodge", aes(label=after_stat(if_else (condition = count>0, as.character(count), ""))), vjust = -0.5) +
    geom_histogram(binwidth = 0.5, position = "dodge") +
    scale_fill_identity(
        "BX Barcode",
        labels = sort(unique(tb$valid), decreasing = T),
        guide = "legend"
    ) +
    labs(title = "Reads per BX molecule", subtitle = samplename) +
    xlab("Aligned reads per BX molecule") +
    ylab("Number of occurrences") +
    theme_minimal() +
    theme(
        panel.grid.minor.y = element_blank(),
        panel.grid.minor.x = element_blank()
    )
```


## Inferred molecule Lengths
The chart below shows the distribution of molecule lengths (in 250bp bins) inferred from the first and last alignment
positions along a contig for all alignments associated with a single BX barcode on a given contig.
```{r echo = F}
tb %>% filter(valid == "valid BX") %>%
    ggplot(aes(x = length_inferred)) +
        geom_histogram(binwidth = 250, fill = "#7cb4ec") +
        stat_bin(binwidth = 250, center = 2.5, geom="text", aes(label=after_stat(if_else (condition = count>0, as.character(count), ""))), vjust = -0.5) +
        labs(title = "Inferred Haplotagged Molecule Lengths", subtitle = samplename) +
        xlab("Inferred Length of Molecule (250bp bins)") +
        ylab("Number of occurrences") +
        theme_minimal() +
        theme(
            panel.grid.minor.y = element_blank(),
        )
```

## Total bases aligned
The chart below shows the total number of base-pairs that aligned to the reference genome, grouped by
BX barcode presence and validity. 

```{r echo = F}
tots <- tb %>% 
    group_by(valid) %>%
    summarize(total = sum(aligned_bp))
tots$fill <- case_when(
    tots$valid == "no BX" ~ "#cf79c8",
    tots$valid == "invalid BX" ~ "#f19a29",
    tots$valid == "valid BX" ~ "#7cb4ec"
)

ggplot(tots, aes(x = valid, y = total, fill = fill)) +
    geom_col() +
    scale_fill_identity(
        "BX Barcode",
        labels = sort(unique(tots$valid), decreasing = T),
        guide = "legend"
    ) +
    geom_text(aes(label = total), position = position_stack(vjust = .5)) +
    coord_flip() +
    labs(title = "Total base-pairs aligned", subtitle = samplename) +
    ylab("Number of aligned base-pairs") +
    xlab("") +
    theme_minimal() +
    theme(panel.grid.major.y = element_blank()
)

```

## Potential barcode clashing
The table below identifies instances when reads with the same BX barcode aligned
to multiple contigs. If the table isn't empty, there are a few possibilities as to why that might have happened:

1. **By chance**: more than one molecule was tagged with the same BX barcode
2. **Mapping error**: the reads were incorrectly mapped
3. **Assembly error**: the alignments are correct, but the assembly has a misassembly
4. **Fragmented assembly**: the alignments are correct and the contigs originated from the same chromosome

If you suspect the culprit is because of #1, you can filter out alignments with particular
barcodes using:
```
# specify a single barcode #
filterBXBAM.py --input `r bamfile` --remove A01C22B23D96

# or with a file of one-per-line BX barcodes #
filterBXBAM.py --input `r bamfile` --remove rmBX.txt
```

```{r echo = F}
clashes <- tb %>%
    filter(valid == "valid BX") %>%
    select(contig, bx) %>%
    group_by(bx) %>%
    mutate(n_clashes = length(unique(contig)), occurs_in = paste(contig, sep = ",")) %>%
    filter(n_clashes > 1) %>%
    select(bx, n_clashes, occurs_in)
DT::datatable(clashes, rownames = F, filter = "top", extensions = 'Buttons', options = list(dom = 'Brtip', buttons = c('csv', 'pdf'), scrollX = TRUE))
```
