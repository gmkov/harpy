---
title: "Haplotag Molecule Report"
date: "`r format(Sys.time(), '%m-%d-%y %X')`"
output:
  flexdashboard::flex_dashboard:
    theme: lumen
    orientation: rows
    vertical_layout: scroll
    horizontal_layout: fill
    favicon: "https://raw.githubusercontent.com/pdimens/harpy/docs/static/favicon_dark.png"
---

```{r echo = F, results = F, message = F}
library(flexdashboard)
library(dplyr)
library(ggplot2)
library(plotly)
library(magrittr)
library(DT)
library(scales)
```

```{r echo = F, results = F, message = F}
#infile <- "~/file.bxstats.gz"
#mdist <- scales::comma(200000)
infile <- snakemake@input[[1]]
mdist <- snakemake@params[[1]]
bamfile <- gsub(".bxstats.gz", ".bam", infile)
samplename <- gsub(".bxstats.gz", "", basename(infile))
tb <- read.table(infile, header = T, sep = "\t") %>% select(-start, -end)
tb$valid <- tb$molecule
tb[!(tb$valid %in% c("noBX", "invalidBX")), "valid"] <- "validBX"
tb$valid <- gsub("BX", " BX", tb$valid)
```

```{r bxper, echo = F, results = F, message = F}
valids <- tb[!(tb$valid %in% c("no BX", "invalid BX")),]
nBX <- group_by(valids, contig) %>% 
  summarize(nBX = length(molecule))

avgBX <- round(mean(nBX$nBX), digits = 2)

totuniqBX <- length(unique(valids$molecule))

tots <- tb %>% 
    group_by(valid) %>%
    summarize(total = length(molecule)) %>% 
    as.data.frame()
for(i in c("no BX", "invalid BX", "valid BX")){
  if (!(i %in% tots$valid)){
    tots <- rbind(tots, data.frame("valid" = i, total = 0))
  }
}
```

```{r binformatter, echo = F, results = F, message = F}
formatBins <- function(x){
    spl <- strsplit(levels(x), ",")
    lefts <- gsub("\\(", "", sapply(spl, "[[", 1)) |> as.numeric() |> scales::comma()
    rights <- gsub("\\]", "", sapply(spl, "[[", 2)) |> as.numeric()
    rights <- scales::comma(rights - 1)
    return(
        paste(lefts, rights, sep = "-")
    )
}
```

## fileheader
### hdr {.no-title}
<h1> Haplotag Barcode Statistics </h1>
The information presented below were gathered from the alignments within `r basename(bamfile)`.


## General Information {data-height=100}
### ncontigs
```{r}
valueBox(scales::comma(length(unique(tb$contig))), caption = "Contigs")
```

### validBX
```{r}
valueBox(scales::comma(tots[tots$valid == "valid BX", 2]), caption = "Valid Barcodes", color = "success", icon = "fa-vial-circle-check")
```

### invalidBX
```{r}
valueBox(scales::comma(tots[tots$valid == "invalid BX", 2]), caption = "Invalid Barcodes", color = "warning", icon = "fa-x")
```

### noBX
```{r}
valueBox(scales::comma(tots[tots$valid == "no BX", 2]), caption = "Missing Barcodes", color = "danger", icon = "fa-exclamation")
```

### glob-avg
```{r}
valueBox(scales::comma(avgBX), caption = "Average BX per contig", color = "info")
```

### glob-total
```{r}
valueBox(scales::comma(totuniqBX), caption = "Total unique barcodes", color = "info")
```

## Reads per molecule dec
### Reads per mol dec {.no-title}
<h2> Reads per Molecule </h2>
The chart below shows the distribution of the number of reads per haplotag molecule. That is, how many alignments
are associated with a unique molecule. This excludes the number of reads associated with invalid
or absent haplotag barcodes.

### bases per desc {.no-title}
<h2> Total Bases Aligned </h2>
Below is a cumulative frequency distribution showing the number of base pairs aligned
per unique molecule. These data are shown in 500 bp bins.


## Reads per molecule
### Reads per mol {.no-title}
```{r echo = FALSE, message = FALSE, warning = FALSE, out.width = '100%'}
p <- filter(tb, valid == "valid BX") %>%
    ggplot(aes(reads)) +
    stat_ecdf(aes(group=1), geom="line", pad = F, color = "#8484bd") +
    stat_ecdf(aes(group=1), geom="point", pad = F, shape = 21, size = 3, fill = "#8484bd", color = "white") +
    labs(
        title = "Reads Per Unique Molecule",
        subtitle = samplename,
        x = "Number of aligned reads",
        y = "% of molecules",
    ) +
    theme_light() +
    theme(panel.grid.minor.y = element_blank())

ggplotly(p)
```

### Bases Per Barcode {.no-title}
```{r echo = FALSE, message = FALSE, warning = FALSE, out.width = '100%'}
dat.binned <- tb %>% filter(valid == "valid BX", length_inferred > 10) %>%
    count(Marks = cut(aligned_bp, seq(0,max(aligned_bp)+500, 500))) %>%
    mutate(pct = n/sum(n)) %>% mutate("Cumulative_Percent" = round(cumsum(pct) * 100,2), "Size_Range" = Marks)

levels(dat.binned$Size_Range) <- formatBins(dat.binned$Size_Range)

p <- ggplot(data = dat.binned, mapping = aes(Size_Range, Cumulative_Percent)) +  
  #geom_bar(stat = "identity", aes(group = 1), fill = "#99cccc", color = "white") +
  geom_line(aes(group = 1), color = "#99cccc") + 
  geom_point(size = 3, shape = 21, color = "white", fill = "#99cccc") +
  labs(
    title = "Bases Aligned Per Unique Molecule",
    subtitle = samplename,
    x = "Number of aligned bases (bp)",
    y = "% of molecules",
  ) +
  #scale_x_discrete(labels = label_number()) +
  theme_light() +
  theme(panel.grid.minor.y = element_blank())  
ggplotly(p) %>% layout(hovermode = "x")

#p <- tb %>% filter(valid == "valid BX", length_inferred > 10) %>%
#    ggplot(aes(x = aligned_bp)) +
#        geom_histogram(binwidth = 500, fill = "#99cccc", color = "white", center = 0) +
#        labs(title = "Bases Aligned Per Unique Molecule", subtitle = samplename) +
#        xlab("Number of aligned bases (500 bp bins)") +
#        ylab("Number of occurrences") +
#        theme_light() +
#        scale_y_continuous(labels = scales::comma) +
#        #scale_x_binned() +
#        scale_x_continuous(labels = scales::comma) +
#        theme(
#            panel.grid.minor.y = element_blank(),
#        )
#ggplotly(p)
```
## inferred-header
### inferred desc {.no-title}
<h2> Inferred Molecule Lengths </h2>
The chart below shows the **cumulative** frequency distribution of molecule lengths 
inferred from the first and last alignment positions along a contig for all
alignments associated with a single haplotag barcode on a given contig. For
visual clarity, molecules with inferred lengths less than 500 bp were omitted,
therefore the Y axis will likely not reach 100%.

## Inferred
### Inferred molecule Lengths
```{r echo = FALSE, message = FALSE, warning = FALSE, out.width = '100%'}
dat.binned <- tb %>% filter(valid == "valid BX") %>% mutate(length_inferred = length_inferred/1000) %>%
    count(Marks = cut(length_inferred, seq(0,max(length_inferred)+5, 5))) %>%
    mutate(pct = n/sum(n)) %>% mutate("Cumulative_Percent" = round(cumsum(pct) * 100,2), "Size_Range" = Marks)

levels(dat.binned$Size_Range) <- formatBins(dat.binned$Size_Range)
p <- ggplot(data = dat.binned, mapping = aes(Size_Range, Cumulative_Percent)) +  
  geom_line(aes(group = 1), color = "#9393d2") + 
  geom_point(data = dat.binned, size = 1, color = "#6b6b9c") +
  labs(
    title = "Inferred Molecule Length",
    subtitle = samplename,
    x = "Molecule Size Bin (kbp)",
    y = "% of Molecules"
  ) +
  scale_y_continuous(trans = "log10") +
  theme_light() +
  theme(panel.grid.minor.y = element_blank())  

ggplotly(p) %>% layout(hovermode = "x")

#mols <- tb %>% filter(valid == "valid BX") %>%
#  arrange(desc(length_inferred)) %>% mutate(percent = round(100/n() * 1:n(), digits = 2)) %>%
#  filter(length_inferred >= 500)
#p <- ggplot(mols, aes(x = length_inferred, y = percent)) +
#        geom_point(color = "#609ad1") +
#        geom_line(color = "#609ad1", alpha = 0.3) +
#        labs(title = "Inferred Molecule Lengths", subtitle = samplename) +
#        xlab("Inferred Molecule Length (bp)") +
#        ylab("% of Molecules") +
#        theme_light() +
#        scale_x_continuous(labels = scales::comma, trans='log10')
#ggplotly(p)
```

## Interpreting the supporting data
### interp desc {.no-title}
<h2> Interpreting the Data </h2>
Below are details on how to interpret the information presented in this report, as well as the 
underlying data used to create this report.

## inttable
### interpreting {.no-title}
<h3> Interpreting the Supporting File </h3>
Listed below are the descriptions of the columns in **`r basename(infile)`**, which was created
by Harpy using the included `bxStats.py` script. The term `molecule` refers to the
`MI:i` tag in the alignments, which is a unique molecule ID given to the original
fragment alignments sharing a barcode are inferred to have originated from. The inference
takes into account an [alignment distance threshold](https://pdimens.github.io/harpy/haplotagdata/#barcode-thresholds)
and that the sequences aligned to the same contig.

```{r cols_explained, echo=FALSE, message=FALSE, warnings=FALSE}
knitr::kable(
  data.frame(
    "Column Name" = c("contig", "molecule", "reads", "start", "end", "length_inferred", "aligned_bp", "mindist"),
    "Description" = c(
      "name of the contig the molecule occurs on",
      "the molecule name as given by the MI:i: tag",
      "number of alignments associated with this molecule",
      "the start position of the first alignment for that molecule",
      "the end position of the last alignment for that molecule",
      "inferred length of the molecule based on the start/end of the alignments sharing the same barcode",
      "total number of base pairs aligned for that molecule",
      "the minimum basepair distance between two alignments sharing a barcode (excluding read pairs, kind of a sanity check)"
      )
    )
)
```

## Interpreting this report
### Barcode validity {.no-title}
<h3> Interpreting Barcode Validity </h3>
BX barcode validity is classified into one of three categories:

```{r bx_explanation, echo=FALSE, message=FALSE, warnings=FALSE}
knitr::kable(
  data.frame(
    "Classification" = c("valid BX", "invalid BX", "no BX"),
    "Description" = c(
      "a complete BX barcode was present in the read (i.e. no 00 for any segments)",
      "a barcode was present in the read, but it contained 00 in at least one of the barcode segments",
      "no barcode was present in the read"
      )
    )
)
```

### Molecule splitting {.no-title}
<h3> Molecule Splitting, Explained </h3>

It's common for a barcode shared by reads not originating from the same molecule
to reappear much further along a chromosome or across multiple chromosomes. The 
process that derives the data in this report separates those recurring barcodes
as unique molecules when their distance is greater than a predetermined threshold. 
If aligned with `BWA` or `minimap2`, Harpy added a corresponding `MI:i:` (Molecular
Identifier) tag that reflects splits given the molecule distance threshold you
specified (`r mdist`). If aligned with `EMA`, the `EMA` software itself 
determines the splits and assigns the `MI:i` tag without user specification.
