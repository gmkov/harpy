---
title: "NAIBR Variant Calling Summary"
author:
    - "Created using HARPY"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    highlight: tango
    number_sections: no
    theme: cosmo
    df_print: kable
    toc: no
---

```{r echo = FALSE, warnings = FALSE, message = FALSE}
infile <- snakemake@input[["bedpe"]]
fai <- snakemake@input[["fai"]]
#infile <- "/home/pdimens/ZS10.bedpe"
#fai <- "/home/pdimens/assembly.fai"
samplename <- gsub(".bedpe", "", basename(infile))
```
#### Sample: `r samplename`


```{r echo = FALSE, warnings = FALSE, message = FALSE, results = 'asis'}
variants <- read.table(infile, header = T) 
if (nrow(variants) == 0) {
  cat(paste0("There are no variants in the file ", "`", infile, "`"))
  knitr::knit_exit()
}
```

Below is a series of tables and plots detailing the structural variants
identified by [NAIBR](https://github.com/pontushojer/NAIBR) [(publication)](https://doi.org/10.1093/bioinformatics/btx712).
The variants are given by:

```{r table2, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
data.frame(
  "Name" = c("Inversion", "Duplication", "Deletion"),
  "Description" = c(
    "a segment that broke off and reattached within the same chromosome, but in reverse orientation",
    "a type of mutation that involves the production of one or more copies of a gene or region of a chromosome",
    "a type of mutation that involves the loss of one or more nucleotides from a segment of DNA"
    )
  )
```

```{r load environment, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)
library(DT)
library(plotly)
library(circlize)
library(ComplexHeatmap)
```

```{css zoom-lib-src, echo = FALSE, message = FALSE, warning = FALSE}
script src = "https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"
```
```{js zoom-jquery, echo = FALSE, message = FALSE, warning = FALSE}
 $(document).ready(function() {
    $('body').prepend('<div class=\"zoomDiv\"><img src=\"\" class=\"zoomImg\"></div>');
    // onClick function for all plots (img's)
    $('img:not(.zoomImg)').click(function() {
      $('.zoomImg').attr('src', $(this).attr('src')).css({width: '100%'});
      $('.zoomDiv').css({opacity: '1', width: 'auto', border: '1px solid white', borderRadius: '5px', position: 'fixed', top: '50%', left: '50%', marginRight: '-50%', transform: 'translate(-50%, -50%)', boxShadow: '0px 0px 50px #888888', zIndex: '50', overflow: 'auto', maxHeight: '100%'});
    });
    // onClick function for zoomImg
    $('img.zoomImg').click(function() {
      $('.zoomDiv').css({opacity: '0', width: '0%'}); 
    });
  });
```

```{r echo = FALSE, warnings = FALSE, message = FALSE}
cleanbedpe <- function(x){
  y <- x[x$Chr1==x$Chr2, c(-3,-10)]
  y$Score <- round(y$Score, digits = 3)
  y$Length <- abs(y$Break2 - y$Break1)
  names(y)[1] <- "Contig"
  return(y)
}

chimeric <- function(x){
  y <- x[x$Chr1!=x$Chr2, -10]
  y$Score <- round(y$Score, digits = 3)
  names(y)[1] <- "Contig"
  return(y)
}
```

```{r echo = FALSE, warnings = FALSE, message = FALSE}
fa.sizes <- read.table(fai, header = F) %>% arrange(desc(2))
colnames(fa.sizes) <- c("contig", "size")
# limit the data to only the 30 largest contigs
fa.sizes <- fa.sizes[1:min(nrow(fa.sizes), 30), ]
```

## Various Stats {.tabset}
### interpreting output
NAIBR outputs a tab-delimited file with named columns (along with a VCF
and a reformatted bedpe file with extra information). The columns of the
bedpe file are deciphered as such:

| Column Name | Description |
| :--- | :--- |
| Chr1 | Contig name of first breakpoint |
| Break1 | Base-pair position in `Chr1` of first breakpoint |
| Chr2 | Contig name of second breakpoint |
| Break2 | Base-pair position in `Chr2` of second breakpoint |
| SplitMolecules | Number of split molecules supporting variant |
| DiscordantReads | Number of discordant reads supporting variant |
| Orientation | Orientation of variant relative to reference |
| Haplotype | The haplotype of the variant |
| Score | log-likelihood score for variant |
| Pass filter | `PASS` if passes internal NAIBR filter threshold, otherwise `FAIL` |


### variants
This table details the variants detected by NAIBR that appear on a single contig/chromosome and passed the programs internal filtering.
```{r echo = FALSE, warnings = FALSE, message = FALSE}
sv <- variants |>cleanbedpe()

DT::datatable(sv[,-10], rownames = F, filter = "top", extensions = 'Buttons', options = list(dom = 'Brtip', buttons = c('csv'), scrollX = TRUE))
```
### chimeric variants

This table shows any structural variants whose breakpoints span multiple contigs and may require further assessment. These variants are not shown in the plots below.

```{r echo = FALSE, warnings = FALSE, message = FALSE}
DT::datatable(chimeric(variants), rownames = F, filter = "top", extensions = 'Buttons', options = list(dom = 'Brtip', buttons = c('csv'), scrollX = TRUE))

```

### summary info
This table shows the overall statistics for counts and lengths of detected structural variants.
```{r echo = FALSE, message = FALSE}
grpstats <- sv %>%
  group_by(Contig, SV) %>%
  summarise(n = n())

svlen <- sv %>% group_by(SV) %>%  summarise(mlen = mean(Length), sdlen = sd(Length))

grpstats %>%
  group_by(SV) %>%
  summarise(
    count = sum(n),
    avg_per_contig = round(mean(n), 2),
    sd = round(sd(n), 2)
) %>% 
  mutate(avg_len = round(svlen$mlen, 2), sd_len = round(svlen$sdlen, 2))

```

### per-contig info
This table details how many of each type of structural variant appear in each contig.
```{r echo = FALSE, message = FALSE, warning = FALSE}
grpstats <- sv %>%
  group_by(Contig, SV) %>%
  summarise(count = n(), total_bp  = sum(Length))

DT::datatable(grpstats, rownames = F, filter = "top", extensions = 'Buttons', options = list(dom = 'Brtip', buttons = c('csv'), scrollX = TRUE), colnames = c('Contig', 'Variant Type', 'Count', 'Total Base Pairs'))
```

---

## Variant size and location {.tabset}
### Summary
Below is a circular plot to visualize the distribution of structural variants 
across (up to) 30 of the largest contigs. This should help you assess
the presence/absence of expected variants. Note that this plot does not 
display overlapping variants of the same type. For more detailed and
interactive plots, see the **Per-contig** tab. Clicking the plot below
will expand it.
```{r echo = FALSE, message = FALSE, warning = FALSE, fig.align='center', out.width= "100%"}
circosplot <- function(data, sizes, plottitle){
circos.clear()
col_text <- "grey40"
circos.par("track.height" = 0.8, gap.degree = 3, cell.padding = c(0, 0, 0, 0))
circos.initialize(
  factors = sizes$contig,
  xlim = matrix(c(rep(0, nrow(sizes)), sizes$size), ncol = 2)
)

# contigs
circos.track(
  ylim = c(0, 1),
  bg.col = "grey90",
  bg.border = F,
  track.height = 0.06,
  panel.fun = function(x, y) {
    chr = CELL_META$sector.index
    xlim = CELL_META$xlim
    ylim = CELL_META$ylim
    circos.text(
      mean(xlim),
      mean(ylim),
      chr,
      cex = 0.35,
      col = col_text,
      facing="bending.inside",
      niceFacing = T
    )
  }
)

# x axis
brk <- seq(0, 10, 0.5) * 10^7
circos.track(
  ylim = c(0,1),
  track.index = get.current.track.index(),
  bg.border = F,
  panel.fun = function(x, y) {
    circos.axis(
      h = "top",
      major.at = brk,
      labels = round(brk/10^6, 1),
      labels.cex = 0.4,
      col = col_text,
      labels.col = col_text,
      lwd = 0.7,
      labels.facing = "clockwise"
    )
  }
)

# INV
circos.genomicTrack(
  ylim = c(0,1),
  data = data[data$SV == "inversion",],
  track.height = 0.2,
  bg.border = F,
  panel.fun = function(region, value, ...) {
    circos.genomicRect(region, value, ybottom = 0, ytop = 1, col = "#4a9fea", border = "#4a9fea")
  }
)


circos.genomicTrack(
  ylim = c(0,1),
  data = data[data$SV == "deletion",],
  track.height = 0.2,
  bg.border = F,
  panel.fun = function(region, value, ...) {
    circos.genomicRect(region, value, ybottom = 0, ytop = 1, col = "#5a8c84", border = "#5a8c84")
  }
)

circos.genomicTrack(
  ylim = c(0,1),
  data = data[data$SV == "duplication",],
  track.height = 0.2,
  bg.border = F,
  panel.fun = function(region, value, ...) {
    circos.genomicRect(region, value, ybottom = 0, ytop = 1, col = "#ffd75f", border =  "#ffd75f")
  }
)
title(plottitle)

lgd <- Legend(
  at = c("Inversion", "Deletion", "Duplication"),
  type = "grid",
  legend_gp = gpar(fill = c("#4a9fea", "#5a8c84", "#ffd75f")),
  title_position = "topleft",
  title = "Variant Type"
)

draw(lgd, x = unit(0.95, "npc"), just = c("right", "bottom"))
}
```

```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE, out.width="100%"}
circosplot(sv, fa.sizes, samplename)
```

### Per-contig
Below are a series of plots to help you assess what structural variants were detected by NAIBR. These plots are interactive,
allowing you to hover over a variant to provide additional information, including the genomic interval in which it occurs and the
number of haplotag barcodes supporting the variant.
```{r colors, echo = FALSE, warning = FALSE, message = FALSE}
col.palette <- c(
  "deletion" = "#5a8c84",
  "duplication" = "#ffd75f",
  "inversion" = "#4a9fea"
  )
```

```{r echo = FALSE, out.width = '100%', warning=FALSE}
l <- htmltools::tagList()
for (i in 1:nrow(fa.sizes)) {
  sv.filt <- sv %>% filter(Contig == fa.sizes$contig[i])
  sv_stats <- group_by(sv.filt, SV) %>% summarise(n = length(SV))
  if (nrow(sv_stats) == 0) {
    next
  }
  plt <- sv.filt %>%
    ggplot() +
    geom_rect(
      alpha = 0.7,
      aes(
        xmin = Break1,
        xmax = Break2,
        ymin = 0,
        ymax = 1,
        fill = SV,
        color = SV,
        text = sprintf("Type: %s<br>Position: %s-%s<br>barcodes: %s", SV, Break1, Break2, SplitMolecules)
      )
    ) +
    theme_light() +
    facet_grid(rows = vars(SV)) +
    theme(
      axis.text.y=element_blank(),
      axis.line.y = element_blank(),
      axis.ticks.y = element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      strip.background = element_rect(fill = "grey80"),
      strip.text = element_text(color = "grey20"),
      legend.position = "none"
    ) +
    scale_color_manual(values = col.palette) +
    scale_fill_manual(values = col.palette) +
    xlim(1, fa.sizes$size[i]) +
    coord_cartesian(xlim = c(0, fa.sizes$size[i] + 1), expand = F) +
    xlab("Position (bp)") +
    labs(fill = "SV type", color = "SV type") +
    ggtitle(fa.sizes$contig[i])
  l[[i]] <- ggplotly(plt, tooltip = "text")
}
l
```

