---
title: "BX Bardcode Summary"
date: "`r format(Sys.time(), '%m-%d-%y %X')`"
output:
  flexdashboard::flex_dashboard:
    theme: lumen
    orientation: columns
    vertical_layout: scroll
    favicon: "https://raw.githubusercontent.com/pdimens/harpy/docs/static/favicon.png"
---
  
```{r echo = FALSE, message = FALSE}
library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(magrittr)
library(DT)
library(plotly)
```
## Barcode Validation
### overview {.no-title}
This report details the counts of valid and invalid haplotag barcodes in the sample read headers.
The correct haplotag format is `BX:Z:AXXCXXBXXDXX`, where there is a whitespace/tab before `BX:Z:` 
and `XX` are 2-digit numbers between `00` and `96`. A valid FASTQ read header would then look like:
```
@A00814:267:HTMH3DRXX:2:1101:4580:1000 BX:Z:A02C01B11D46        RX:Z:GAAACGACCAACA+CGAACACGTTAGC   QX:Z:F,FFFFFFFFFFF+FF,FFF:FFFFFF
```
Notably, only the sequence ID (`@...`) and `BX:Z:` tag are required. In the example above, there are additional tags 
(`RX:Z:` and `QX:Z:`) which arent used by Harpy, but they conform to the 
[SAM comment spec (section 1.5)](https://samtools.github.io/hts-specs/SAMv1.pdf) of `TAG:TYPE:VALUE`. The takeaway 
is that the `BX:Z` tag can be anywhere in the read header after the sequence ID as long as any tags after it conform to the SAM spec `TAG:TYPE:VALUE`. 



### Per Sample Plot
Below is a plot summarizing the number of valid vs invalid barcodes per sample.

```{r echo = FALSE, message = FALSE, warning = FALSE}
plotdata <- BXstats %>%
  select(Sample, BarcodeValid, BarcodeInvalid) %>% 
  rename(Valid = BarcodeValid, Invalid = BarcodeInvalid)

percdata <- BXstats %>%
  select(Sample, PercentValid, PercentInvalid) %>% 
  rename(Valid= PercentValid, Invalid = PercentInvalid)

pltheight <- max(50 * length(unique(plotdata$Sample)), 300)
```

```{r echo = FALSE, message = FALSE, warning = FALSE, out.width = '100%'}
p <-  plotdata %>%
  pivot_longer(-Sample, names_to = "BarcodeStatus", values_to = "Count") %>%
  ggplot(aes(y = Sample, x = Count, fill = BarcodeStatus)) +
    geom_col() +
    theme_minimal() +
    theme(panel.grid.major.y = element_blank(), axis.title.y = element_blank()) +
    scale_fill_manual(values = c(Valid = "#afd5e7", Invalid = "#c02554")) +
    scale_x_continuous(labels = scales::comma) +
    labs(title = "Summary of Valid Barcodes")

ggplotly(p, height = pltheight)
```

### % Per Sample Plot
Below is a plot summarizing the number of valid vs invalid barcodes per sample as a percentage
of the total reads for that sample.

```{r echo = FALSE, message = FALSE, warning = FALSE, out.width = '100%'}
pc <- percdata %>%
  pivot_longer(-Sample, names_to = "BarcodeStatus", values_to = "Percent") %>%
  ggplot(aes(y = Sample, x = Percent, fill = BarcodeStatus)) +
    geom_col() +
    theme_minimal() +
    theme(panel.grid.major.y = element_blank(), axis.title.y = element_blank()) +
    scale_fill_manual(values = c(Valid = "#afd5e7", Invalid = "#c02554")) +
    xlim(0, 100) +
    scale_x_continuous(labels = scales::comma) +
    labs(title = "Summary of Valid Barcodes")

ggplotly(pc, height = pltheight)
```

### Table {.no-title}
Below is a table listing all the samples Harpy processed and their associated barcode statistics as
determined by the reads in the **forward read only**. If `BarcodeTotal` equals `0` for some reason, 
then there may be an issue with the format of your FASTQ headers.

```{r echo = FALSE, message = FALSE, warning = FALSE}
BXstats <- data.frame(
  Sample = character(),
  TotalReads = integer(),
  ReadsIgnored = integer(),
  BarcodeValid = integer(),
  BarcodeTotal = integer(),
  PercentValid = numeric(),
  PercentIgnored = numeric()
)

invalids <- data.frame(
  Sample = character(),
  A = integer(),
  C = integer(),
  B = integer(),
  D = integer()
)

#for (i in c("~/stats.1.count.log", "~/stats.2.count.log")) {
for (i in snakemake@input[["countlog"]]) {
  samplename <- gsub(".count.log", "", basename(i))
  s_df <- read.table(i, header = F)
  total <- s_df$V2[1]
  bc_total <- s_df$V2[2]
  bc_ok <- s_df$V2[3]
  bc_invalid <- s_df$V2[4]
  if (bc_total == 0) {
    bc_percent <- 0
    ig_percent <- 0
  } else {
    bc_percent <- trunc((bc_ok / bc_total) * 10000) / 100
    ig_percent <- trunc((bc_invalid / bc_total) * 10000) / 100
  }

  BXstats <- rbind(
    BXstats,
    data.frame(
      Sample = samplename,
      TotalReads = total,
      BarcodePresent = bc_total,
      BarcodeValid = bc_ok,
      PercentValid = bc_percent,
      BarcodeInvalid = bc_invalid,
      PercentInvalid = ig_percent
      )
  )
  invalids <- rbind(
    invalids,
    data.frame(
      Sample = samplename,
      A = s_df$V2[5],
      C = s_df$V2[6],
      B = s_df$V2[7],
      D = s_df$V2[8]
    )
  )
}
DT::datatable(
  BXstats,
  rownames = FALSE,
  filter = "top",
  extensions = "Buttons",
  options = list(
    dom = "Brtip",
    buttons = c("csv"),
    scrollX = TRUE
  )
)
```

### Invalid by Segment
This table details the count of invalid beadtag segments across all **forward reads** within a sample.
This can help you diagnose if any beadtag segments in your experimental design have a higher incidence
of failure than others.
```{r echo = FALSE, message = FALSE, warning = FALSE}
DT::datatable(
  invalids,
  rownames = FALSE,
  extensions = "Buttons",
  options = list(
    dom = "Brtip",
    buttons = c("csv"),
    scrollX = TRUE
  )
)
```
