---
title: "BCFtools Stats Report"
author:
    - "Created using HARPY"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    highlight: tango
    number_sections: no
    theme: cosmo
    df_print: kable
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: no
      smooth_scroll: yes
---
```{r load environment, echo=FALSE, message=FALSE, warning=FALSE}
library(ggplot2)
library(magrittr)
library(tidyr)
library(dplyr)
library(DT)
library(plotly)
library(scales)
library(RColorBrewer)
#dataL <- readLines("~/checkstats.txt")
dataL <- readLines(snakemake@input[[1]])
bcf <- gsub(".stats$", ".bcf", snakemake@input[[1]])
```
### File: `r bcf`

## General Information
This reflects the general information stored in the records of `r bcf`.
```{r General Stats, echo = FALSE, message = FALSE, warning = FALSE}
.snL <- grepl("^SN", dataL)
sn <- read.table(text=dataL[.snL], sep = "\t")[,3:4]
names(sn) <- c("Metric", "Number")
sn$Metric <- gsub("number of ", "", sn$Metric)
rownames(sn) <- sn$Metric
sn <- as.data.frame(t(sn[2]))
rownames(sn) <- NULL
sn
```

## Individual Statistics {.tabset}
These statistics correspond to the `r sn$samples[1]` samples in `r bcf`.
### Imputation success
This table details the number of `missing` genotypes that were imputed per individual. Following standard VCF convention, `Ref` refers to
the reference allele (from the reference genome), `Alt` refers to the alternative allele, and `Missing` details how many SNPs remain missing
(failed to impute) for that individual. As an example, the `Homozygous Ref` column is the number of missing genotypes that were imputed into
a homozygous genotype for the reference allele.

```{r success table, echo=FALSE, message=FALSE, warning=FALSE}
comparefile <- snakemake@input[[2]]
gcts <- read.table(comparefile, header = F)[, c(2, 23, 25, 24, 27)]
names(gcts) <- c("sample","missing2RRHom", "missing2RAHet",	"missing2AAHom", "missing")

DT::datatable(
  gcts,
  rownames = FALSE,
  extensions = "Buttons",
  colnames = c("Sample", "Homozygous Ref", "Homozygous Alt", "Heterozygote", "Missing"),
  options = list(
    dom = "Brtip",
    buttons = c("csv"),
    scrollX = TRUE
  )
)
```


### plot
```{r Individual plot, echo=FALSE, message=FALSE, warning=FALSE, paged.print=TRUE, out.width="100%"}
.pscL <- grepl("^PSC", dataL)
psc <- read.table(text=dataL[.pscL])[ ,3:14]
names(psc) <- c("Sample", "HomozygousRef", "HomozygousAtl", "Heterozygotes", "Transitions", "Transversions", "Indels",	"MeanDepth", "Singletons",	"HapRef", "HapAlt", "Missing")
psc$Homozygotes <- psc$HomozygousRef + psc$HomozygousAtl
tidy_psc <- pivot_longer(psc[,c(1,4,5,6,7,9,12,13)], -Sample , names_to = "Metric", values_to = "Count")
psc <- psc[,c(1,8,12,2,3,13,4,5,6,7,9,10,11)]

pscplot <- ggplot(data = tidy_psc, mapping = aes(x = Count, y = Sample, color = Metric)) +
  geom_point(size = 2) +
  labs(title = "Individual Statistics") +
  theme_bw() +
  scale_x_continuous(n.breaks=9) +
  xlab("Count") +
  scale_color_brewer(palette = "Dark2") +
  theme(panel.grid.minor = element_blank(), panel.grid.major.y = element_blank(), axis.title.y = element_blank())

ggplotly(pscplot)
```

### table
```{r Individual table, echo=FALSE, message=FALSE, warning=FALSE, paged.print=TRUE, out.width="100%"}
DT::datatable(psc, rownames = F, filter = "top", extensions = 'Buttons', options = list(dom = 'Brtip', buttons = c('csv'), scrollX = TRUE))
```

## INFO Scores {.tabset}
`STITCH` outputs a novel `INFO/INFO_SCORE` tag in the resulting VCF files that represents the
"quality" of the imputation. This value ranges from `0` to `1.0`, with `0` being
very poor, and `1.0` being very good. You will want to filter the resulting variants
based on this `INFO/INFO_SCORE` tag, which can be done that simply with `bcftools`.
Here is an example snippet of keeping loci with an `INFO_SCORE` of at least `0.2`: 
```
bcftools view -i 'INFO/INFO_SCORE >= 0.2' file.vcf
```
### Overall distribution
Below is the frequency distribution of the `INFO_SCORE` values for all the variants
in the VCF file. 
```{r echo=FALSE, message=FALSE, warning=FALSE}
infofile <- snakemake@input[[2]]
#infofile <- "~/impute.infoscore"
infos <- read.table(infofile, header = F, col.names = c("contig", "position", "info"))
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
maxsizes <- infos %>% group_by(contig) %>% summarise(maxsize = max(position)) %>% arrange(desc(maxsize))
maxsizes <- maxsizes[1:min(nrow(maxsizes), 30), ]

ncontig <- nrow(maxsizes)
pltheight <- round(1.5 * ncontig, digits = 0)
```

```{r echo = FALSE, message = FALSE, warning = FALSE, fig.align='center', out.width= "100%"}
ggplot(infos, aes(x = info)) +
  geom_histogram(fill = "grey60", color = "grey53", boundary = 0.5) +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank()
  ) +
  scale_y_continuous(labels = comma) +
  xlab("INFO_SCORE") +
  ylab("Count") +
  labs(title = "Distribution of imputation INFO_SCORE")
```

### Per-contig distribution
Below is the frequency distribution of the `INFO_SCORE` values for the variants
in the VCF file, shown per-contig, up to 30 of the largest contigs. 
```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height=pltheight, fig.align='center', out.width = "100%"}
ggplot(infos[infos$contig %in% maxsizes$contig, ], aes(x = info)) +
  geom_histogram(fill = "grey60", color = "grey53", boundary = 0.5) +
  facet_wrap(~contig, ncol = 2, scales = "free_y") +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank()
  ) +
  scale_y_continuous(labels = comma) +
  xlab("INFO_SCORE") +
  ylab("Count") +
  labs(title = "Distribution of imputation INFO_SCORE")
```

### Potential sites removed
Below is a table of the number of variants sites that may remain if filtering
at different minimum `INFO/INFO_SCORE` thresholds.

```{r echo = FALSE, message = FALSE, warning = FALSE}
filterthresh <- infos %>% group_by(contig) %>%
  summarise(
    totals = length(info),
    twenty = sum(info >= 0.2),
    twentyfive = sum(info >= 0.25),
    thirty = sum(info >= 0.30),
    forty = sum(info >= 0.40),
    fifty = sum(info >= 0.50)
    )

tots <- colSums(filterthresh[, -1])
filterthresh <- rbind(c("all", tots), filterthresh) 

DT::datatable(
  filterthresh,
  rownames = FALSE,
  extensions = "Buttons",
  colnames = c("Contigs", "Total Variants", "0.20", "0.25", "0.30", "0.4", "0.5"),
  options = list(
    dom = "Brtip",
    buttons = c("csv"),
    scrollX = TRUE
  )
)
```
