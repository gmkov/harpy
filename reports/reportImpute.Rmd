---
title: "Imputation Assessment"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  flexdashboard::flex_dashboard:
    theme: lumen
    orientation: rows
    vertical_layout: scroll
    horizontal_layout: fill
    favicon: "https://raw.githubusercontent.com/pdimens/harpy/docs/static/favicon.png"
---
```{r load environment, echo=FALSE, message=FALSE, warning=FALSE}
library(flexdashboard)
library(ggplot2)
library(magrittr)
library(tidyr)
library(dplyr)
library(DT)
library(scales)
modelparams <- paste(snakemake@params[[1]])
#modelparams <- "Filler Text"
```
```{r echo = FALSE, message = FALSE, warning = FALSE}
comparefile <- snakemake@input[[1]]
#comparefile <- "~/impute.compare.stats"
gcts <- read.table(comparefile, header = F)[, c(2, 23, 25, 24, 27)]
names(gcts) <- c("sample","RefHom", "Het",	"AltHom", "missing")

conv_height <- 0.2 * nrow(gcts) 
gcts <- pivot_longer(gcts, -1, names_to = "Conversion", values_to = "Count")
```

## header row
<h1> `r comparefile` </h1>
This report details the results of genotype imputation using STITCH with the model parameters:
`r modelparams`

## Ind stats desc
### plotdesc {.no-title}
This chart visualizes the count and proportion of `missing` genotypes per sample imputed
into other genotypes. Following standard VCF convention, `Ref` refers to
the reference allele (from the reference genome), `Alt` refers to the alternative 
allele, and `Missing` details how many SNPs remain missing
(failed to impute) for that individual. As an example, the `Homozygous Ref` column is 
the number of missing genotypes that were imputed into
a homozygous genotype for the reference allele.

### tabledesc {.no-title}
This table details the number of `missing` genotypes that were imputed into a 
different genotype per individual. These are the data used to create the
visualization on the left.

## Individual Statistics
### Individuals Plot {.no-title}
```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height=conv_height, out.width= "100%"}
ggplot(gcts, aes(y = sample, x = Count, fill = Conversion)) +
  geom_col(position = "stack") +
  scale_x_continuous(expand = c(0,0), labels = comma) +
  ylab("") +
  theme_minimal() +
  theme(panel.grid.major.y = element_blank(), axis.ticks.y = element_line(size = 0.5)) +
  scale_fill_manual(
    labels = c("→ Homozygous Alt", "→ Heterozygote", "→ Missing", "→ Homozygous Ref"),
    values = c("#4a9fea", "#5a8c84", "#424043", "#ffd75f")
  )

```
### Imputation Results Table {.no-title}
```{r success table, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(
  gcts,
  rownames = FALSE,
  extensions = "Buttons",
  colnames = c("Sample", "Homozygous Ref", "Homozygous Alt", "Heterozygote", "Missing"),
  options = list(
    dom = "Brtip",
    buttons = c("csv"),
    scrollX = TRUE
  ),
  autoHideNavigation = T,
  fillContainer = T
)
```

## INFO Scores
### INFO desc {.no-title}

`STITCH` outputs a novel `INFO/INFO_SCORE` tag in the resulting VCF files that represents the
"quality" of the imputation. This value ranges from `0` to `1.0`, with `0` being
very poor, and `1.0` being very good. You will want to filter the resulting variants
based on this `INFO/INFO_SCORE` tag, which can be done that simply with `bcftools`.
Here is an example snippet of keeping loci with an `INFO_SCORE` of at least `0.2`: 
```
# use -Ob to output to bcf instead of vcf to save on disk space

bcftools view -i 'INFO/INFO_SCORE >= 0.2' -Ob file.vcf > filtered.file.bcf
```

## distributions
### Overall distribution {.no-title}
Below is the frequency distribution of the `INFO_SCORE` values for all the variants
in the VCF file. 
```{r echo=FALSE, message=FALSE, warning=FALSE}
infofile <- snakemake@input[[2]]
#infofile <- "~/impute.infoscore"
infos <- read.table(infofile, header = F, col.names = c("contig", "position", "info"))
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
maxsizes <- infos %>% group_by(contig) %>% summarise(maxsize = max(position)) %>% arrange(desc(maxsize))
maxsizes <- maxsizes[1:min(nrow(maxsizes), 30), ]

ncontig <- nrow(maxsizes)
pltheight <- round(1.1 * ncontig, digits = 0)
```

```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height=2.5, out.width= "100%"}
ggplot(infos, aes(x = info)) +
  geom_histogram(fill = "grey60", color = "grey40", linewidth = 0.25, bins = 100, boundary = 0.5) +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank()
  ) +
  scale_y_continuous(labels = comma) +
  xlab("INFO_SCORE") +
  ylab("Count") +
  labs(title = "Distribution of imputation INFO_SCORE")
```

## dist and filter
### Per-contig distribution {.no-title}
<h3> Per-contig INFO_SCORE Distribution </h3>
Below is the frequency distribution of the `INFO_SCORE` values for the variants
in the VCF file, shown per-contig, up to 30 of the largest contigs.

```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height=pltheight, fig.align='center', out.width = "100%"}
ggplot(infos[infos$contig %in% maxsizes$contig, ], aes(x = info)) +
  geom_histogram(fill = "grey60", color = "grey40", linewidth = 0.25, bins = 100, boundary = 0.5) +
  facet_wrap(~contig, ncol = 2, scales = "free_y") +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank()
  ) +
  scale_y_continuous(labels = comma) +
  xlab("INFO_SCORE") +
  ylab("Count") +
  labs(title = "Distribution of imputation INFO_SCORE")
```


### Filtering Expectations {.no-title}
<h3> Filtering Expectations </h3>
Below is a table of the number of variants sites that may remain if filtering
at different minimum `INFO/INFO_SCORE` thresholds. Each column after `Total Variants`
refers to a filtering threshold and the numbers within that column are the number of 
SNPs that would be kept if filtering out SNPs with an `INFO/INFO_SCORE` value below 
it (_i.e._ `0.2` is the number of SNPs with a score `>= 0.2` )

```{r echo = FALSE, message = FALSE, warning = FALSE}
filterthresh <- infos %>% group_by(contig) %>%
  summarise(
    totals = length(info),
    twenty = sum(info >= 0.2),
    twentyfive = sum(info >= 0.25),
    thirty = sum(info >= 0.30),
    forty = sum(info >= 0.40),
    fifty = sum(info >= 0.50)
    )

tots <- colSums(filterthresh[, -1])
filterthresh <- rbind(c("all", tots), filterthresh) 

DT::datatable(
  filterthresh,
  rownames = FALSE,
  extensions = "Buttons",
  colnames = c("Contigs", "Total Variants", "0.20", "0.25", "0.30", "0.4", "0.5"),
  options = list(
    dom = "Brtip",
    buttons = c("csv"),
    scrollX = TRUE
  ),
  autoHideNavigation = T,
  fillContainer = T
)
```
