---
title: "Imputation Assessment"
author:
    - "Created using HARPY"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    highlight: tango
    number_sections: no
    theme: cosmo
    df_print: kable
    toc: no
---
```{r load environment, echo=FALSE, message=FALSE, warning=FALSE}
library(ggplot2)
library(magrittr)
library(tidyr)
library(dplyr)
library(DT)
library(scales)
#modelparams <- paste(snakemake@params[[1]])
modelparams <- "Filler Text"
```
### Imputed genotypes from model: `r modelparams`

## Individual Statistics {.tabset}
### Imputation Results
This table details the number of `missing` genotypes that were imputed into a 
different genotype per individual. Following standard VCF convention, `Ref` refers to
the reference allele (from the reference genome), `Alt` refers to the alternative 
allele, and `Missing` details how many SNPs remain missing
(failed to impute) for that individual. As an example, the `Homozygous Ref` column is 
the number of missing genotypes that were imputed into
a homozygous genotype for the reference allele.

```{r success table, echo=FALSE, message=FALSE, warning=FALSE}
comparefile <- snakemake@input[[1]]
#comparefile <- "~/impute.compare.stats"
gcts <- read.table(comparefile, header = F)[, c(2, 23, 25, 24, 27)]
names(gcts) <- c("sample","RefHom", "Het",	"AltHom", "missing")

DT::datatable(
  gcts,
  rownames = FALSE,
  extensions = "Buttons",
  colnames = c("Sample", "Homozygous Ref", "Homozygous Alt", "Heterozygote", "Missing"),
  options = list(
    dom = "Brtip",
    buttons = c("csv"),
    scrollX = TRUE
  )
)
```
### Plot
This chart visualizes the count and proportion of missing genotypes per sample imputed
into other genotypes (same data as the table from the previous tab).

```{r echo = FALSE, message = FALSE, warning = FALSE}
conv_height <- 0.2 * nrow(gcts) 
gcts <- pivot_longer(gcts, -1, names_to = "Conversion", values_to = "Count")
```

```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height=conv_height, out.width= "100%"}
ggplot(gcts, aes(y = sample, x = Count, fill = Conversion)) +
  geom_col(position = "stack") +
  scale_x_continuous(expand = c(0,0), labels = comma) +
  ylab("") +
  theme_minimal() +
  theme(panel.grid.major.y = element_blank(), axis.ticks.y = element_line(size = 0.5)) +
  scale_fill_manual(
    labels = c("→ Homozygous Alt", "→ Heterozygote", "→ Missing", "→ Homozygous Ref"),
    values = c("#4a9fea", "#5a8c84", "#424043", "#ffd75f")
  )

```

## INFO Scores {.tabset}
`STITCH` outputs a novel `INFO/INFO_SCORE` tag in the resulting VCF files that represents the
"quality" of the imputation. This value ranges from `0` to `1.0`, with `0` being
very poor, and `1.0` being very good. You will want to filter the resulting variants
based on this `INFO/INFO_SCORE` tag, which can be done that simply with `bcftools`.
Here is an example snippet of keeping loci with an `INFO_SCORE` of at least `0.2`: 
```
# use -Ob to output to bcf instead of vcf to save on disk space

bcftools view -i 'INFO/INFO_SCORE >= 0.2' -Ob file.vcf > filtered.file.bcf
```
### Overall distribution
Below is the frequency distribution of the `INFO_SCORE` values for all the variants
in the VCF file. 
```{r echo=FALSE, message=FALSE, warning=FALSE}
infofile <- snakemake@input[[2]]
#infofile <- "~/impute.infoscore"
infos <- read.table(infofile, header = F, col.names = c("contig", "position", "info"))
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
maxsizes <- infos %>% group_by(contig) %>% summarise(maxsize = max(position)) %>% arrange(desc(maxsize))
maxsizes <- maxsizes[1:min(nrow(maxsizes), 30), ]

ncontig <- nrow(maxsizes)
pltheight <- round(1.1 * ncontig, digits = 0)
```

```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height=2.5, out.width= "100%"}
ggplot(infos, aes(x = info)) +
  geom_histogram(fill = "grey60", color = "grey40", linewidth = 0.25, bins = 100, boundary = 0.5) +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank()
  ) +
  scale_y_continuous(labels = comma) +
  xlab("INFO_SCORE") +
  ylab("Count") +
  labs(title = "Distribution of imputation INFO_SCORE")
```

### Per-contig distribution
Below is the frequency distribution of the `INFO_SCORE` values for the variants
in the VCF file, shown per-contig, up to 30 of the largest contigs. 
```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height=pltheight, fig.align='center', out.width = "100%"}
ggplot(infos[infos$contig %in% maxsizes$contig, ], aes(x = info)) +
  geom_histogram(fill = "grey60", color = "grey40", linewidth = 0.25, bins = 100, boundary = 0.5) +
  facet_wrap(~contig, ncol = 2, scales = "free_y") +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank()
  ) +
  scale_y_continuous(labels = comma) +
  xlab("INFO_SCORE") +
  ylab("Count") +
  labs(title = "Distribution of imputation INFO_SCORE")
```

### Potential sites removed
Below is a table of the number of variants sites that may remain if filtering
at different minimum `INFO/INFO_SCORE` thresholds. Each column after `Total Variants`
refers to a filtering threshold and the numbers within that column are the number of 
SNPs that would be kept if filtering out SNPs with an `INFO/INFO_SCORE` value below it (_i.e._ `0.2` is the number of SNPs with a score `>= 0.2` )

```{r echo = FALSE, message = FALSE, warning = FALSE}
filterthresh <- infos %>% group_by(contig) %>%
  summarise(
    totals = length(info),
    twenty = sum(info >= 0.2),
    twentyfive = sum(info >= 0.25),
    thirty = sum(info >= 0.30),
    forty = sum(info >= 0.40),
    fifty = sum(info >= 0.50)
    )

tots <- colSums(filterthresh[, -1])
filterthresh <- rbind(c("all", tots), filterthresh) 

DT::datatable(
  filterthresh,
  rownames = FALSE,
  extensions = "Buttons",
  colnames = c("Contigs", "Total Variants", "0.20", "0.25", "0.30", "0.4", "0.5"),
  options = list(
    dom = "Brtip",
    buttons = c("csv"),
    scrollX = TRUE
  )
)
```
